// Generated by CoffeeScript 1.6.2
(function() {
  var UglifyJS, browserify, chokidar, colors, convertSourceMap, fs, options, path, through;

  path = require("path");

  fs = require("fs");

  colors = require("colors");

  browserify = require("browserify");

  chokidar = require("chokidar");

  through = require("through");

  convertSourceMap = require("convert-source-map");

  UglifyJS = require("uglify-js");

  options = {
    ignore: /(\/\.|~$)/,
    watch: true,
    debug: true,
    minify: false,
    build: {
      "coffee": function(file, data) {
        var coffee, comment, compiled;

        coffee = require("coffee-script");
        compiled = coffee.compile(data, {
          sourceMap: true,
          generatedFile: true,
          inline: true
        });
        comment = convertSourceMap.fromJSON(compiled.v3SourceMap).setProperty("sources", [file]).toComment();
        return compiled.js + "\n" + comment;
      }
    }
  };

  module.exports = function(ops, out) {
    var basedir, bundle, file, files, key, uglify, value, vendor, vendorBuild, watcher, _i, _len, _ref, _ref1;

    if ((typeof ops === "string" || ops instanceof String) && (typeof out === "string" || out instanceof String)) {
      options.main = ops;
      options.out = out;
    } else {
      for (key in ops) {
        value = ops[key];
        if (key !== "build") {
          options[key] = value;
        }
      }
      if (ops.build) {
        _ref = ops.build;
        for (key in _ref) {
          value = _ref[key];
          options.build[key] = value;
        }
      }
    }
    basedir = path.dirname(module.parent.filename);
    watcher = chokidar.watch(path.resolve(basedir, options.main), {
      ignored: options.ignore,
      ignoreInitial: true,
      persistent: true
    });
    bundle = function(i, o) {
      var start;

      start = Date.now();
      return browserify().transform(function(file) {
        var data, end, ext, func, write, _ref1;

        watcher.add(file);
        _ref1 = options.build;
        for (ext in _ref1) {
          func = _ref1[ext];
          if (RegExp("\." + ext + "$").test(file)) {
            data = "";
            write = function(buf) {
              return data += buf;
            };
            end = function() {
              this.queue(func(file, data));
              return this.queue(null);
            };
            return through(write, end);
          }
        }
        return through();
      }).require(path.resolve(basedir, i), {
        entry: true
      }).bundle({
        debug: options.debug
      }, function(err, src) {
        if (err) {
          return console.log("[piping-browser]".bold.yellow, "Error:", err);
        } else {
          if (options.minify) {
            uglify(src, path.resolve(basedir, o));
          } else {
            fs.writeFileSync(path.resolve(basedir, o), src);
          }
          return console.log("[piping-browser]".bold.yellow, "Built in", Date.now() - start, "ms");
        }
      });
    };
    uglify = function(files, output, inputmap) {
      var code, comment, compressed, compressor, file, map, mapopts, toplevel, _i, _len;

      toplevel = null;
      if (!(typeof files === "string" || files instanceof String)) {
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          code = fs.readFileSync(file, "utf8");
          toplevel = UglifyJS.parse(code, {
            filename: file,
            toplevel: toplevel
          });
        }
      } else {
        toplevel = UglifyJS.parse(files, {
          filename: "bundle.js"
        });
      }
      toplevel.figure_out_scope();
      compressor = UglifyJS.Compressor();
      compressed = toplevel.transform(compressor);
      compressed.figure_out_scope();
      compressed.compute_char_frequency();
      compressed.mangle_names();
      if (options.debug) {
        mapopts = {
          file: output
        };
        if (inputmap) {
          mapopts.orig = inputmap;
        }
        map = UglifyJS.SourceMap(mapopts);
        code = compressed.print_to_string({
          source_map: map
        });
        comment = convertSourceMap.fromObject(map.get()).toComment();
        code += "\n" + comment;
      } else {
        code = compressed.print_to_string();
      }
      return fs.writeFileSync(output, code);
    };
    watcher.on("change", function(file) {
      console.log("[piping-browser]".bold.yellow, "File", path.relative(process.cwd(), file), "has changed, rebuilding");
      if (options.watch) {
        return bundle(options.main, options.out);
      }
    });
    if (options.vendor && options.vendor.files.length && options.vendor.out && options.vendor.path) {
      files = [];
      _ref1 = options.vendor.files;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        files.push(path.resolve(basedir, options.vendor.path, file));
      }
      vendor = chokidar.watch(files, {
        ignored: options.ignore,
        ignoreInitial: true,
        persistent: true
      });
      vendorBuild = function(out) {
        var code, start, _j, _len1;

        start = Date.now();
        if (options.minify) {
          uglify(files, path.resolve(basedir, out));
        } else {
          code = ";";
          for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
            file = files[_j];
            code += fs.readFileSync(file, "utf8") + ";\n";
          }
          fs.writeFileSync(path.resolve(basedir, out), code);
        }
        return console.log("[piping-browser]".bold.yellow, "Vendor built in", Date.now() - start, "ms");
      };
      vendor.on("change", function(file) {
        console.log("[piping-browser]".bold.yellow, "File", path.relative(process.cwd(), file), "has changed, rebuilding vendor");
        if (options.watch) {
          return vendorBuild(options.vendor.out);
        }
      });
      vendorBuild(options.vendor.out);
    }
    return bundle(options.main, options.out);
  };

}).call(this);
