// Generated by CoffeeScript 1.6.2
(function() {
  var UglifyJS, browserify, chokidar, colors, convertSourceMap, fs, options, path, through;

  path = require("path");

  fs = require("fs");

  colors = require("colors");

  browserify = require("browserify");

  chokidar = require("chokidar");

  through = require("through");

  convertSourceMap = require("convert-source-map");

  UglifyJS = require("uglify-js");

  options = {
    ignore: /(\/\.|~$)/,
    watch: true,
    debug: true,
    minify: false,
    build: {
      "coffee": function(file, data) {
        var coffee, comment, compiled;

        coffee = require("coffee-script");
        compiled = coffee.compile(data, {
          sourceMap: true,
          generatedFile: true,
          inline: true
        });
        comment = convertSourceMap.fromJSON(compiled.v3SourceMap).setProperty("sources", [file]).toComment();
        return compiled.js + "\n" + comment;
      },
      "jade": function(file, data) {
        var compiled, jade;

        jade = require("jade");
        compiled = jade.compile(data, {
          compileDebug: false,
          client: true,
          filename: file
        });
        return "module.exports=" + compiled;
      }
    }
  };

  module.exports = function(ops, out) {
    var basedir, bundle, file, files, key, main, uglify, value, vendor, vendorBuild, vendorOut, watcher, _i, _len, _ref, _ref1;

    if ((typeof ops === "string" || ops instanceof String) && (typeof out === "string" || out instanceof String)) {
      options.main = ops;
      options.out = out;
    } else {
      for (key in ops) {
        value = ops[key];
        if (key !== "build") {
          options[key] = value;
        }
      }
      if (ops.build) {
        _ref = ops.build;
        for (key in _ref) {
          value = _ref[key];
          options.build[key] = value;
        }
      }
    }
    basedir = path.dirname(module.parent.filename);
    main = path.resolve(basedir, options.main);
    out = path.resolve(basedir, options.out);
    watcher = chokidar.watch(path.resolve(basedir, options.main), {
      ignored: options.ignore,
      ignoreInitial: true,
      persistent: true
    });
    bundle = function(i, o) {
      var e, start;

      start = Date.now();
      try {
        return browserify().transform(function(file) {
          var data, end, ext, func, write, _ref1;

          watcher.add(file);
          _ref1 = options.build;
          for (ext in _ref1) {
            func = _ref1[ext];
            if (RegExp("\." + ext + "$").test(file)) {
              data = "";
              write = function(buf) {
                return data += buf;
              };
              end = function() {
                this.queue(func(file, data));
                return this.queue(null);
              };
              return through(write, end);
            }
          }
          return through();
        }).require(i, {
          entry: true
        }).bundle({
          debug: options.debug
        }, function(err, src) {
          if (err) {
            return console.log("[piping-browser]".bold.yellow, "Error:", err);
          } else {
            if (options.minify) {
              uglify(src, o);
            } else {
              fs.writeFileSync(o, src);
            }
            return console.log("[piping-browser]".bold.yellow, "Built in", Date.now() - start, "ms");
          }
        });
      } catch (_error) {
        e = _error;
        return console.log("[piping-browser]".bold.yellow, "Failed to build", path.relative(process.cwd(), i), e);
      }
    };
    uglify = function(files, output, inputmap) {
      var code, comment, compressed, compressor, file, map, mapopts, toplevel, _i, _len;

      toplevel = null;
      if (!(typeof files === "string" || files instanceof String)) {
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          code = fs.readFileSync(file, "utf8");
          toplevel = UglifyJS.parse(code, {
            filename: file,
            toplevel: toplevel
          });
        }
      } else {
        toplevel = UglifyJS.parse(files, {
          filename: "bundle.js"
        });
      }
      toplevel.figure_out_scope();
      compressor = UglifyJS.Compressor();
      compressed = toplevel.transform(compressor);
      compressed.figure_out_scope();
      compressed.compute_char_frequency();
      compressed.mangle_names();
      if (options.debug) {
        mapopts = {
          file: output
        };
        if (inputmap) {
          mapopts.orig = inputmap;
        }
        map = UglifyJS.SourceMap(mapopts);
        code = compressed.print_to_string({
          source_map: map
        });
        comment = convertSourceMap.fromObject(map.get()).toComment();
        code += "\n" + comment;
      } else {
        code = compressed.print_to_string();
      }
      return fs.writeFileSync(output, code);
    };
    watcher.on("change", function(file) {
      if (!options.watch) {
        return;
      }
      console.log("[piping-browser]".bold.yellow, "File", path.relative(process.cwd(), file), "has changed, rebuilding");
      return bundle(main, out);
    });
    if (options.vendor && options.vendor.files.length && options.vendor.out && options.vendor.path) {
      files = [];
      vendorOut = path.resolve(basedir, options.vendor.out);
      _ref1 = options.vendor.files;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        files.push(path.resolve(basedir, options.vendor.path, file));
      }
      vendor = chokidar.watch(files, {
        ignored: options.ignore,
        ignoreInitial: true,
        persistent: true
      });
      vendorBuild = function(files, out) {
        var code, start, _j, _len1;

        start = Date.now();
        if (options.minify) {
          uglify(files, out);
        } else {
          code = ";";
          for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
            file = files[_j];
            code += fs.readFileSync(file, "utf8") + ";\n";
          }
          fs.writeFileSync(out, code);
        }
        return console.log("[piping-browser]".bold.yellow, "Vendor built in", Date.now() - start, "ms");
      };
      vendor.on("change", function(file) {
        if (!options.watch) {
          return;
        }
        console.log("[piping-browser]".bold.yellow, "File", path.relative(process.cwd(), file), "has changed, rebuilding vendor");
        return vendorBuild(files, vendorOut);
      });
      vendorBuild(files, vendorOut);
    }
    return bundle(main, out);
  };

}).call(this);
